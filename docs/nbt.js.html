<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: nbt.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: nbt.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
	NBT.js - a JavaScript parser for NBT archives
	by Sijmen Mulder

	I, the copyright holder of this work, hereby release it into the public
	domain. This applies worldwide.

	In case this is not legally possible: I grant anyone the right to use this
	work for any purpose, without any conditions, unless such conditions are
	required by law.
*/

(function() {
	'use strict';

	if (typeof ArrayBuffer === 'undefined') {
		throw new Error('Missing required type ArrayBuffer');
	}
	if (typeof DataView === 'undefined') {
		throw new Error('Missing required type DataView');
	}
	if (typeof Uint8Array === 'undefined') {
		throw new Error('Missing required type Uint8Array');
	}

	/** @exports nbt */

	var nbt = this;

	/**
	 * A mapping from type names to NBT type numbers.
	 * {@link module:nbt.Writer} and {@link module:nbt.Reader}
	 * have correspoding methods (e.g. {@link module:nbt.Writer#int})
	 * for every type.
	 *
	 * @type Object&lt;string, number>
	 * @see module:nbt.tagTypeNames */
	nbt.tagTypes = {
		'end': 0,
		'byte': 1,
		'short': 2,
		'int': 3,
		'long': 4,
		'float': 5,
		'double': 6,
		'byteArray': 7,
		'string': 8,
		'list': 9,
		'compound': 10,
		'intArray': 11,
		'longArray': 12
	};

	/**
	 * A mapping from NBT type numbers to type names.
	 *
	 * @type Object&lt;number, string>
	 * @see module:nbt.tagTypes */
	nbt.tagTypeNames = {};
	(function() {
		for (var typeName in nbt.tagTypes) {
			if (nbt.tagTypes.hasOwnProperty(typeName)) {
				nbt.tagTypeNames[nbt.tagTypes[typeName]] = typeName;
			}
		}
	})();

	function hasGzipHeader(data) {
		var head = new Uint8Array(data.slice(0, 2));
		return head.length === 2 &amp;&amp; head[0] === 0x1f &amp;&amp; head[1] === 0x8b;
	}

	function encodeUTF8(str) {
		var array = [], i, c;
		for (i = 0; i &lt; str.length; i++) {
			c = str.charCodeAt(i);
			if (c &lt; 0x80) {
				array.push(c);
			} else if (c &lt; 0x800) {
				array.push(0xC0 | c >> 6);
				array.push(0x80 | c         &amp; 0x3F);
			} else if (c &lt; 0x10000) {
				array.push(0xE0 |  c >> 12);
				array.push(0x80 | (c >>  6) &amp; 0x3F);
				array.push(0x80 |  c        &amp; 0x3F);
			} else {
				array.push(0xF0 | (c >> 18) &amp; 0x07);
				array.push(0x80 | (c >> 12) &amp; 0x3F);
				array.push(0x80 | (c >>  6) &amp; 0x3F);
				array.push(0x80 |  c        &amp; 0x3F);
			}
		}
		return array;
	}

	function decodeUTF8(array) {
		var codepoints = [], i;
		for (i = 0; i &lt; array.length; i++) {
			if ((array[i] &amp; 0x80) === 0) {
				codepoints.push(array[i] &amp; 0x7F);
			} else if (i+1 &lt; array.length &amp;&amp;
						(array[i]   &amp; 0xE0) === 0xC0 &amp;&amp;
						(array[i+1] &amp; 0xC0) === 0x80) {
				codepoints.push(
					((array[i]   &amp; 0x1F) &lt;&lt; 6) |
					( array[i+1] &amp; 0x3F));
			} else if (i+2 &lt; array.length &amp;&amp;
						(array[i]   &amp; 0xF0) === 0xE0 &amp;&amp;
						(array[i+1] &amp; 0xC0) === 0x80 &amp;&amp;
						(array[i+2] &amp; 0xC0) === 0x80) {
				codepoints.push(
					((array[i]   &amp; 0x0F) &lt;&lt; 12) |
					((array[i+1] &amp; 0x3F) &lt;&lt;  6) |
					( array[i+2] &amp; 0x3F));
			} else if (i+3 &lt; array.length &amp;&amp;
						(array[i]   &amp; 0xF8) === 0xF0 &amp;&amp;
						(array[i+1] &amp; 0xC0) === 0x80 &amp;&amp;
						(array[i+2] &amp; 0xC0) === 0x80 &amp;&amp;
						(array[i+3] &amp; 0xC0) === 0x80) {
				codepoints.push(
					((array[i]   &amp; 0x07) &lt;&lt; 18) |
					((array[i+1] &amp; 0x3F) &lt;&lt; 12) |
					((array[i+2] &amp; 0x3F) &lt;&lt;  6) |
					( array[i+3] &amp; 0x3F));
			}
		}
		return String.fromCharCode.apply(null, codepoints);
	}

	/* Not all environments, in particular PhantomJS, supply
	   Uint8Array.slice() */
	function sliceUint8Array(array, begin, end) {
		if ('slice' in array) {
			return array.slice(begin, end);
		} else {
			return new Uint8Array([].slice.call(array, begin, end));
		}
	}

	/**
	 * In addition to the named writing methods documented below,
	 * the same methods are indexed by the NBT type number as well,
	 * as shown in the example below.
	 *
	 * @constructor
	 * @see module:nbt.Reader
	 *
	 * @example
	 * var writer = new nbt.Writer();
	 *
	 * // all equivalent
	 * writer.int(42);
	 * writer[3](42);
	 * writer(nbt.tagTypes.int)(42);
	 *
	 * // overwrite the second int
	 * writer.offset = 0;
	 * writer.int(999);
	 *
	 * return writer.buffer; */
	nbt.Writer = function() {
		var self = this;

		/* Will be resized (x2) on write if necessary. */
		var buffer = new ArrayBuffer(1024);

		/* These are recreated when the buffer is */
		var dataView = new DataView(buffer);
		var arrayView = new Uint8Array(buffer);

		/**
		 * The location in the buffer where bytes are written or read.
		 * This increases after every write, but can be freely changed.
		 * The buffer will be resized when necessary.
		 *
		 * @type number */
		this.offset = 0;

		// Ensures that the buffer is large enough to write `size` bytes
		// at the current `self.offset`.
		function accommodate(size) {
			var requiredLength = self.offset + size;
			if (buffer.byteLength >= requiredLength) {
				return;
			}

			var newLength = buffer.byteLength;
			while (newLength &lt; requiredLength) {
				newLength *= 2;
			}

			var newBuffer = new ArrayBuffer(newLength);
			var newArrayView = new Uint8Array(newBuffer);
			newArrayView.set(arrayView);

			// If there's a gap between the end of the old buffer
			// and the start of the new one, we need to zero it out
			if (self.offset > buffer.byteLength) {
				newArrayView.fill(0, buffer.byteLength, self.offset);
			}

			buffer = newBuffer;
			dataView = new DataView(newBuffer);
			arrayView = newArrayView;
		}

		function write(dataType, size, value) {
			accommodate(size);
			dataView['set' + dataType](self.offset, value);
			self.offset += size;
			return self;
		}

		/**
		 * Returns the writen data as a slice from the internal buffer,
		 * cutting off any padding at the end.
		 *
		 * @returns {ArrayBuffer} a [0, offset] slice of the interal buffer */
		this.getData = function() {
			accommodate(0);  /* make sure the offset is inside the buffer */
			return buffer.slice(0, self.offset);
		};

		/**
		 * @method module:nbt.Writer#byte
		 * @param {number} value - a signed byte
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.byte] = write.bind(this, 'Int8', 1);

		/**
		 * @method module:nbt.Writer#ubyte
		 * @param {number} value - an unsigned byte
		 * @returns {module:nbt.Writer} itself */
		this.ubyte = write.bind(this, 'Uint8', 1);

		/**
		 * @method module:nbt.Writer#short
		 * @param {number} value - a signed 16-bit integer
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.short] = write.bind(this, 'Int16', 2);

		/**
		 * @method module:nbt.Writer#int
		 * @param {number} value - a signed 32-bit integer
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.int] = write.bind(this, 'Int32', 4);

		/**
		 * @method module:nbt.Writer#float
		 * @param {number} value - a signed 32-bit float
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.float] = write.bind(this, 'Float32', 4);

		/**
		 * @method module:nbt.Writer#float
		 * @param {number} value - a signed 64-bit float
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.double] = write.bind(this, 'Float64', 8);

		/**
		 * As JavaScript does not support 64-bit integers natively, this
		 * method takes an array of two 32-bit integers that make up the
		 * upper and lower halves of the long.
		 *
		 * @method module:nbt.Writer#long
		 * @param {Array.&lt;number>} value - [upper, lower]
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.long] = function(value) {
			self.int(value[0]);
			self.int(value[1]);
			return self;
		};

		/**
		 * @method module:nbt.Writer#byteArray
		 * @param {Array.&lt;number>|Uint8Array|Buffer} value
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.byteArray] = function(value) {
			this.int(value.length);
			accommodate(value.length);
			arrayView.set(value, this.offset);
			this.offset += value.length;
			return this;
		};

		/**
		 * @method module:nbt.Writer#intArray
		 * @param {Array.&lt;number>} value
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.intArray] = function(value) {
			this.int(value.length);
			var i;
			for (i = 0; i &lt; value.length; i++) {
				this.int(value[i]);
			}
			return this;
		};

		/**
		 * @method module:nbt.Writer#longArray
		 * @param {Array.&lt;number>} value
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.longArray] = function(value) {
			this.int(value.length);
			var i;
			for (i = 0; i &lt; value.length; i++) {
				this.long(value[i]);
			}
			return this;
		};

		/**
		 * @method module:nbt.Writer#string
		 * @param {string} value
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.string] = function(value) {
			var bytes = encodeUTF8(value);
			this.short(bytes.length);
			accommodate(bytes.length);
			arrayView.set(bytes, this.offset);
			this.offset += bytes.length;
			return this;
		};

		/**
		 * @method module:nbt.Writer#list
		 * @param {Object} value
		 * @param {number} value.type - the NBT type number
		 * @param {Array} value.value - an array of values
		 * @returns {module:nbt.Writer} itself */
		this[nbt.tagTypes.list] = function(value) {
			this.byte(nbt.tagTypes[value.type]);
			this.int(value.value.length);
			var i;
			for (i = 0; i &lt; value.value.length; i++) {
				this[value.type](value.value[i]);
			}
			return this;
		};

		/**
		 * @method module:nbt.Writer#compound
		 * @param {Object} value - a key/value map
		 * @param {Object} value.KEY
		 * @param {string} value.KEY.type - the NBT type number
		 * @param {Object} value.KEY.value - a value matching the type
		 * @returns {module:nbt.Writer} itself
		 *
		 * @example
		 * writer.compound({
		 *     foo: { type: 'int', value: 12 },
		 *     bar: { type: 'string', value: 'Hello, World!' }
		 * }); */
		this[nbt.tagTypes.compound] = function(value) {
			var self = this;
			Object.keys(value).map(function (key) {
				self.byte(nbt.tagTypes[value[key].type]);
				self.string(key);
				self[value[key].type](value[key].value);
			});
			this.byte(nbt.tagTypes.end);
			return this;
		};

		var typeName;
		for (typeName in nbt.tagTypes) {
			if (nbt.tagTypes.hasOwnProperty(typeName)) {
				this[typeName] = this[nbt.tagTypes[typeName]];
			}
		}
	};

	/**
	 * In addition to the named writing methods documented below,
	 * the same methods are indexed by the NBT type number as well,
	 * as shown in the example below.
	 *
	 * @constructor
	 * @see module:nbt.Writer
	 *
	 * @example
	 * var reader = new nbt.Reader(buf);
	 * int x = reader.int();
	 * int y = reader[3]();
	 * int z = reader[nbt.tagTypes.int](); */
	nbt.Reader = function(buffer) {
		if (!buffer) { throw new Error('Argument "buffer" is falsy'); }

		var self = this;

		/**
		 * The current location in the buffer. Can be freely changed
		 * within the bounds of the buffer.
		 *
		 * @type number */
		this.offset = 0;

		var arrayView = new Uint8Array(buffer);
		var dataView = new DataView(arrayView.buffer);

		function read(dataType, size) {
			var val = dataView['get' + dataType](self.offset);
			self.offset += size;
			return val;
		}

		/**
		 * @method module:nbt.Reader#byte
		 * @returns {number} the read byte */
		this[nbt.tagTypes.byte] = read.bind(this, 'Int8', 1);

		/**
		 * @method module:nbt.Reader#byte
		 * @returns {number} the read unsigned byte */
		this.ubyte = read.bind(this, 'Uint8', 1);

		/**
		 * @method module:nbt.Reader#short
		 * @returns {number} the read signed 16-bit short  */
		this[nbt.tagTypes.short] = read.bind(this, 'Int16', 2);

		/**
		 * @method module:nbt.Reader#int
		 * @returns {number} the read signed 32-bit integer */
		this[nbt.tagTypes.int] = read.bind(this, 'Int32', 4);

		/**
		 * @method module:nbt.Reader#float
		 * @returns {number} the read signed 32-bit float */
		this[nbt.tagTypes.float] = read.bind(this, 'Float32', 4);

		/**
		 * @method module:nbt.Reader#double
		 * @returns {number} the read signed 64-bit float */
		this[nbt.tagTypes.double] = read.bind(this, 'Float64', 8);

		/**
		 * As JavaScript does not not natively support 64-bit
		 * integers, the value is returned as an array of two
		 * 32-bit integers, the upper and the lower.
		 *
		 * @method module:nbt.Reader#long
		 * @returns {Array.&lt;number>} [upper, lower] */
		this[nbt.tagTypes.long] = function() {
			return [this.int(), this.int()];
		};

		/**
		 * @method module:nbt.Reader#byteArray
		 * @returns {Array.&lt;number>} the read array */
		this[nbt.tagTypes.byteArray] = function() {
			var length = this.int();
			var bytes = [];
			var i;
			for (i = 0; i &lt; length; i++) {
				bytes.push(this.byte());
			}
			return bytes;
		};

		/**
		 * @method module:nbt.Reader#intArray
		 * @returns {Array.&lt;number>} the read array of 32-bit ints */
		this[nbt.tagTypes.intArray] = function() {
			var length = this.int();
			var ints = [];
			var i;
			for (i = 0; i &lt; length; i++) {
				ints.push(this.int());
			}
			return ints;
		};

		/**
		 * As JavaScript does not not natively support 64-bit
		 * integers, the value is returned as an array of arrays of two
		 * 32-bit integers, the upper and the lower.
		 *
		 * @method module:nbt.Reader#longArray
		 * @returns {Array.&lt;number>} the read array of 64-bit ints
		 *     split into [upper, lower] */
		this[nbt.tagTypes.longArray] = function() {
			var length = this.int();
			var longs = [];
			var i;
			for (i = 0; i &lt; length; i++) {
				longs.push(this.long());
			}
			return longs;
		};

		/**
		 * @method module:nbt.Reader#string
		 * @returns {string} the read string */
		this[nbt.tagTypes.string] = function() {
			var length = this.short();
			var slice = sliceUint8Array(arrayView, this.offset,
				this.offset + length);
			this.offset += length;
			return decodeUTF8(slice);
		};

		/**
		 * @method module:nbt.Reader#list
		 * @returns {{type: string, value: Array}}
		 *
		 * @example
		 * reader.list();
		 * // -> { type: 'string', values: ['foo', 'bar'] } */
		this[nbt.tagTypes.list] = function() {
			var type = this.byte();
			var length = this.int();
			var values = [];
			var i;
			for (i = 0; i &lt; length; i++) {
				values.push(this[type]());
			}
			return { type: nbt.tagTypeNames[type], value: values };
		};

		/**
		 * @method module:nbt.Reader#compound
		 * @returns {Object.&lt;string, { type: string, value }>}
		 *
		 * @example
		 * reader.compound();
		 * // -> { foo: { type: int, value: 42 },
		 * //      bar: { type: string, value: 'Hello! }} */
		this[nbt.tagTypes.compound] = function() {
			var values = {};
			while (true) {
				var type = this.byte();
				if (type === nbt.tagTypes.end) {
					break;
				}
				var name = this.string();
				var value = this[type]();
				values[name] = { type: nbt.tagTypeNames[type], value: value };
			}
			return values;
		};

		var typeName;
		for (typeName in nbt.tagTypes) {
			if (nbt.tagTypes.hasOwnProperty(typeName)) {
				this[typeName] = this[nbt.tagTypes[typeName]];
			}
		}
	};

	/**
	 * @param {Object} value - a named compound
	 * @param {string} value.name - the top-level name
	 * @param {Object} value.value - a compound
	 * @returns {ArrayBuffer}
	 *
	 * @see module:nbt.parseUncompressed
	 * @see module:nbt.Writer#compound
	 *
	 * @example
	 * nbt.writeUncompressed({
	 *     name: 'My Level',
	 *     value: {
	 *         foo: { type: int, value: 42 },
	 *         bar: { type: string, value: 'Hi!' }
	 *     }
	 * }); */
	nbt.writeUncompressed = function(value) {
		if (!value) { throw new Error('Argument "value" is falsy'); }

		var writer = new nbt.Writer();

		writer.byte(nbt.tagTypes.compound);
		writer.string(value.name);
		writer.compound(value.value);

		return writer.getData();
	};

	/**
	 * @param {Object} value - a named compound
	 * @param {string} value.name - the top-level name
	 * @param {Object} value.value - a compound
	 * @param {gzipCallback}
	 * 
	 * @see module:nbt.parseCompressed
	 * @see module:nbt.Writer#compound
	 * 
	 * @example
	 * nbt.writeCompressed({
	 *     name: 'My Level',
	 *     value: {
	 *         foo: { type: int, value: 42 },
	 *         bar: { type: string, value: 'Hi!' }
	 *     }
	 * })
	 */
	nbt.writeCompressed = function(value, callback) {
		if (!nbt.gzip) {
			callback(new Error('No gzip library available at nbt.gzip'), null);
		} else {
			try {
				var data = nbt.writeUncompressed(value);

				nbt.gzip(data, callback);
			} catch(error) {
				callback(error, null);
			}
		}
	};

	/**
	 * @param {ArrayBuffer|Buffer} data - an uncompressed NBT archive
	 * @returns {{name: string, value: Object.&lt;string, Object>}}
	 *     a named compound
	 *
	 * @see module:nbt.parse
	 * @see module:nbt.writeUncompressed
	 *
	 * @example
	 * nbt.parseUncompressed(buf);
	 * // -> { name: 'My Level',
	 * //      value: { foo: { type: int, value: 42 },
	 * //               bar: { type: string, value: 'Hi!' }}} */
	nbt.parseUncompressed = function(data) {
		if (!data) { throw new Error('Argument "data" is falsy'); }

		var reader = new nbt.Reader(data);

		var type = reader.byte();
		if (type !== nbt.tagTypes.compound) {
			throw new Error('Top tag should be a compound');
		}

		return {
			name: reader.string(),
			value: reader.compound()
		};
	};

	/**
	 * @callback parseCallback
	 * @param {Object} error
	 * @param {Object} result - a named compound
	 * @param {string} result.name - the top-level name
	 * @param {Object} result.value - the top-level compound */

	/**
	 * This accepts both gzipped and uncompressd NBT archives.
	 * If the archive is uncompressed, the callback will be
	 * called directly from this method. For gzipped files, the
	 * callback is async.
	 *
	 * For use in the browser, nbt.unzip must be defined to decode
	 * compressed archives. It will be passed a Buffer if the type is
	 * available, or an Uint8Array otherwise.
	 *
	 * @param {ArrayBuffer|Buffer} data - gzipped or uncompressed data
	 * @param {parseCallback} callback
	 *
	 * @see module:nbt.parseUncompressed
	 * @see module:nbt.Reader#compound
	 *
	 * @example
	 * nbt.parse(buf, function(error, results) {
	 *     if (error) {
	 *         throw error;
	 *     }
	 *     console.log(result.name);
	 *     console.log(result.value.foo);
	 * }); */
	nbt.parse = function(data, callback) {
		if (!data) { throw new Error('Argument "data" is falsy'); }

		var self = this;

		if (!hasGzipHeader(data)) {
			callback(null, self.parseUncompressed(data));
		} else if (!nbt.gunzip) {
			callback(new Error('No gunzip library available at nbt.gunzip'), null);
		} else {
			/* zlib.gunzip take a Buffer, at least in Node, so try to convert
			   if possible. */
			var buffer;
			if (data.length) {
				buffer = data;
			} else if (typeof Buffer !== 'undefined') {
				buffer = new Buffer(data);
			} else {
				/* In the browser? Unknown zlib library. Let's settle for
				   Uint8Array and see what happens. */
				buffer = new Uint8Array(data);
			}

			nbt.gunzip(buffer, function(error, uncompressed) {
				if (error) {
					callback(error, null);
				} else {
					callback(null, self.parseUncompressed(uncompressed));
				}
			});
		}
	};

	/**
	 * @callback gunzipCallback
	 * @param {Object} error
	 * @param {ArrayBuffer|Buffer|Uint8Array} result - uncompressed data */

	/**
	 * @param {ArrayBuffer|Buffer|Uint8Array} data - gzipped data
	 * @param {gunzipCallback} callback
	 */
	nbt.gunzip = function(data, callback) {};
	if (typeof require === 'undefined') {
		if (!window.zlib) {
			nbt.gunzip = window.zlib.gunzip;
		} else if (!window.pako) {
			nbt.gunzip = function(data, callback) {
				try {
					callback(null, window.pako.ungzip(data));
				} catch(error) {
					callback(error, null);
				}
			};
		} else {
			nbt.gunzip = null;
		}
	} else {
		nbt.gunzip = require('zlib').gunzip;
	}

	/**
	 * @callback gzipCallback
	 * @param {Object} error
	 * @param {ArrayBuffer|Buffer|Uint8Array} result - gzipped data */

	/**
	 * @param {ArrayBuffer|Buffer|Uint8Array} data - uncompressed data
	 * @param {gzipCallback} callback
	 */
	nbt.gzip = function(data, callback) {};
	if (typeof require === 'undefined') {
		if (!window.zlib) {
			nbt.gzip = window.zlib.gzip;
		} else if (!window.pako) {
			nbt.gzip = function(data, callback) {
				try {
					callback(null, window.pako.gzip(data));
				} catch(error) {
					callback(error, null);
				}
			};
		} else {
			nbt.gzip = null;
		}
	} else {
		nbt.gzip = require('zlib').gzip;
	}

	/**
	 * Destructively and recursively remove type and value parameters
	 * from a named compound object. Using nbt.growCompound will often
	 * not revert to the same variable types.
	 * 
	 * Beware:
	 * - Bigger datatypes than 32 bits are split into arrays, index 0
	 * 	 referencing first set of bytes, index 1 referencing next set of
	 * 	 bytes, etc.
	 * - Not recommended to use this unless you already know the layout
	 *   of the compound object.
	 * - Minecraft sometimes stores unsigned numbers as signed types and
	 *   you will have to unsign their values yourself by ANDing the bit
	 * 	 length of the type - 1. (Byte eg. ubyte = byte &amp; 0xff)
	 * 
	 * @param {Object} compound - a named compound
	 * @param {string} compound.name - the top-level name
	 * @param {Object} compound.value - a compound
	 * @returns {Object} - a shrinked compound
	 * 
	 * @example
	 * nbt.shrinkCompound({
	 *     name: 'Top Level',
	 *     value: {
	 *         foo: { type: 'int', value: 42 },
	 *  	   bar: { type: 'compound', value: {
	 * 		       age: { type: 'byte', value: 22 }
	 * 		   }}
	 *     }
	 * })
	 * // -> { foo: 42, bar: { age: 22 } }
	 */
	nbt.shrinkCompound = function(compound) {
		if (!compound.value) {
			return null;
		}

		if (typeof compound.value === 'string' ||
			typeof compound.value === 'number') {
				return compound.value;
		}
		
		if (compound.type === 'byteArray') {
			return compound.value.map(function(byte) {
				return byte; // &amp; 0xff;
			});
		}
	
		if (compound.type === 'longArray') {
			return compound.value.map(function(value) {
				return [value[0] , value[1]];
			});
		}

		if (compound.type === 'long' ||
			compound.type === 'double') {
			return compound.value
		}
	
		if (compound.type === 'list') {
			if (compound.value.type === 'compound') {
				return compound.value.value.map(function(object) {
					return nbt.shrinkCompound({ value:object });
				});
			} else {
				return compound.value.value;
			}
		}
	
		var shrinkedObject = {};
		Object.entries(compound.value).forEach(function(entry) {
			shrinkedObject[entry[0]] = nbt.shrinkCompound(entry[1]);
		});
		
		return shrinkedObject;
	};

	/**
	 * Attempts to reconstruct a named compound object from a shrinked
	 * compound. The method uses the smallest sized number type for every
	 * number, meaning byte, short, int, long and float, double can be
	 * different from before nbt.shrinkCompound was used.
	 * 
	 * Beware:
	 * - If shrinkedCompound is bad the output may look close to right
	 *   even if it is wrong.
	 * 
	 * @param {Object} shrinkedCompound - a shrinked compound
	 * @param {string} shrinkedCompound.name - the top-level name
	 * @param {Object} shrinkedCompound.value - a compound
	 * @returns {Object} - a named compound
	 * 
	 * @example
	 * nbt.growCompound({
	 * 	   foo: 42,
	 *     bar: {
	 *         age: 22
	 *     }
	 * })
	 * // -> {
	 *     name: '',
	 *     value: {
	 *         foo: { type: 'byte', value: 42 },
	 *  	   bar: { type: 'compound', value: {
	 * 		       age: { type: 'byte', value: 22 }}}}}
	 */
	nbt.growCompound = function(shrinkedCompound) {
		if (typeof shrinkedCompound !== 'object') {
			return null;
		}

		return { name:'', value:grow(shrinkedCompound).value };
	};

	function grow(object) {
		if (object == null) {
			return null;
		}

		if (typeof object === 'string') {
			return { type:'string', value:object };
		}

		if (typeof object === 'number') {
			var type;
			if (object % 1 === 0) {
				var numBytes = Math.max(1, Math.ceil(Math.log2(object) / 8));
				if (numBytes === 1) {
					type = 'byte';
				} else if (numBytes &lt;= 2) {
					type = 'short';
				} else if (numBytes &lt;= 4) {
					type = 'int';
				} else {
					type = 'long';
				}
			} else {
				if (object % 1 * 1e6 % 1 === 0) {
					type = 'float';
				} else {
					type = 'double';
				}
			}
			return { type:type, value:object };
		}

		if (object instanceof Array) {
			if (object.length === 2 &amp;&amp;
				typeof object[0] === 'number') {
					// TODO: could be double list?
					return { type:'long', value:object }
			} else {
				var type = 'list', value;
				if (object.length === 0) {
					// impossible to know type of array
					value = { type:'int', value:object };
				} else {
					if (object[0] instanceof Array) {
						// TODO: could be double list?
						value = { type:'long', value:object }
					} else if (typeof object[0] === 'object') {
						value = {
							type: 'compound',
							value: object.map(function(obj) {
								return grow(obj).value;
							})
						}
					} else {
						var type = grow(object[0]).type;
						if (type === 'byte') {
							type = 'byteArray';
							value = object;
						} else if (type === 'int') {
							type = 'intArray';
							value = object;
						} else {
							value = { type:type, value:object };
						}
					}
				}
				return { type:type, value:value };
			}
		}

		var grown = { type:'compound', value:{} };

		Object.entries(object).forEach(function(entry) {
			grown.value[entry[0]] = grow(entry[1]);
		});

		return grown;
	}
}).apply(typeof exports !== 'undefined' ? exports : (window.nbt = {}));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-nbt.html">nbt</a></li></ul><h3>Classes</h3><ul><li><a href="module-nbt.Reader.html">Reader</a></li><li><a href="module-nbt.Writer.html">Writer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Jan 19 2020 20:16:18 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
